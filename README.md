# MinecraftOS

这是一个在 Minecraft 中制作的简单操作系统，主要用于整活。嗯。

（这活整的可不容易啊……）

PS：别骂了别骂了，是我菜，只会写 Python……

## 运行

1. 启动 Minecraft 1.12 服务器。需安装 [RaspberryJuice](https://github.com/zhuowei/RaspberryJuice) 插件。
2. 启动 `main.py`。

```bash
python main.py
```

## 贡献

您可以向该储存库提交 PR。

下面还有一些文档，希望能帮助您看懂我的代码（💩）。

## 定义 / 消歧义

- **位**：一个二进制码所占空间为一位。
- **字节**：八位组成的数据所占空间为一字节。
- **五位** / **五位二进制**：五位组成的数据所占空间，或游戏中一格方块最多能存储的数据为五位。

## 文件系统

### 基础

使用方块的组合（见 [syscore/mem/external/blocks.py](./syscore/mem/external/blocks.py)）存储数据，每个方块可以存储五位二进制。

但是我最担心的事情还是发生了。

字节（八个二进制）和方块（五个二进制）完全不兼容，他俩完全就是互素的。

这就直接导致 write 一次和分开来 write 两次不幂等。

这不仅带来了资源的浪费，还直接导致：同时读取这两段*分开来写的*数据时，会出现乱码。

怎么解决？

1. 尽量只写一次就达到最终效果。写入文件的时候，给个缓存让用户操作，关闭文件之后再给存进去。
2. 把指针精确到二进制。

思来想去还是选择方案二更好，更符合用户直观感受。

### 硬盘

每个硬盘开头的第一个逻辑块有一串数据，指示其信息。其格式如下：

| 长度 | 进制 | 含义               | 示例 |
| ---- | ---- | ------------------ | ---- |
| 2    | Hex  | 版本号             | 2c   |
| 4    | Hex  | 逻辑块长度（字节） | 0400 |
| 1    | Hex  | 二进制指针长度 $n$ | 6    |

~~看我多聪明，还留了两位版本号~~

目前硬盘版本号为 `0`。请理解，**目前该项目处于内测状态，不保证向上兼容性**，请在使用时考虑这一点。

紧随其后的是位图，指示每个逻辑块的使用情况。如果硬盘总空间为 $s$ 字节，逻辑块长度为 $b$ 字节，那么位图长度 $c$ 位为：

$$
c=\lfloor \frac{s}{b} \rfloor.
$$

格式化硬盘时，分配逻辑块。每个逻辑块开头一位指示其存储的是否是索引节点（inode）：`1` 为 inode，`0` 为实际数据，超级块或未分配。最后 $n$ 位指示下一个逻辑块的指针。

有一点非常例外：假设一个 inode 非常非常长，占用了 2 个甚至多个逻辑块，那么只有第一个逻辑块标记为 inode，其余均不标记。这是为了防止错误地从中间开始读取 inode。

*特别注意：指向逻辑块的指针应指向逻辑块第一位。*

由于服务端处理能力有限，读取速度稳定在约 `10` 秒读 `1024` 字节（`8192` 位），请在使用时尽可能减少 IO 次数。

<!--
### 目录项（Dentry）

既然要存文件，那肯定需要用到 **目录项** 对文件结构加以管理。目录项在第一位为 `1` 的逻辑块中以 bytes 形式存储。

固定地，每 `256` 位为一个基本 **存储单元**，一个目录项必须占用 `256` 的整数倍位。

每个目录项结束段会有一个结束符，表示这个目录项已经结束，下一个存储单元不再是同一个目录项了。
-->

### 索引节点（inode）

索引节点是文件的 **唯一** 标识。
